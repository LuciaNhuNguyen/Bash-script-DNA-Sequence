# **DNA QUALITY CONTROL**

## TOOL INSTALLATION
```bash
# download latest conda installer
$ wget https://repo.anaconda.com/miniconda/Miniconda3-py310_23.1.0-1-Linux-x86_64.sh

# run the installer
$ bash Miniconda3-py310_23.1.0-1-Linux-x86_64.sh

$ conda update --yes conda

# Install some conda channels
# A channel is where conda looks for packages
$ conda config --add channels defaults
$ conda config --add channels bioconda
$ conda config --add channels conda-forge

# Creating environments
$ conda create -n ngs python=3.10

# activate the environment
$ conda activate ngs

# Install more tools into the environment
$ conda install package
$ conda install -c bioconda bioawk

# to search for packages
$ conda search [package]

# To update all packages
$ conda update --all --yes

# List all packages installed
$ conda list [-n env]

# conda list environments
$ conda env list

# create new env
$ conda create -n [name] package [package] ...

# activate env
$ conda activate [name]

# deactivate env
$ conda deactivate
```

## THE DATA
```bash
# create a directory you work in
$ mkdir analysis

# change into the directory
$ cd analysis

# download the data and super-compress file
$ wget -O data.tar.gz https://osf.io/2jc4a/download

# uncompress it
$ tar -xvzf data.tar.gz
```

## INVESTIGATE THE DATA
```bash
# Read file
$ less anc_R1.fast* # for uncompressed file
$ zcat anc_R1.fast*.gz | head -20 # for compressed file
```

### For FASTA files
Once the input file is read, the defline for the FASTA will be \$name variable and the sequence will be \$seq variable. 
```bash
# Count number of reads in a FASTA file
$ awk '{count++} END {print count/4}' input.fasta

# Get length for sequences
$ paste ---- < input.fasta | awk -F"\t" '{print length($2)}'
$ bioawk -c fastx '{ print $name, length($seq) }' input.fasta

# Find motifs in a FASTA file
$ paste ---- < input.fasta | awk -F"\t" '{print $2}' | grep "ACCTT"

# Get %GC for sequences
$ bioawk -c fastx '{ print $name, gc($seq) }' input.fasta

# Get reverse complement for all sequences
$ bioawk -c fastx '{ print ">"$name;print revcomp($seq) }' input.fasta

# Print sequences with length greater than 100 bases
$ bioawk -c fastx 'length($seq) > 100{ print ">"$name; print $seq }'  input.fasta

# Add a prefix/suffix to the sequence defline
$ bioawk -c fastx '{ print ">PREFIX"$name; $seq }' input.fasta
$ bioawk -c fastx '{ print ">"$name"|SUFFIX"; $seq }' input.fasta

# Convert FASTA to tabular format
$ bioawk -t -c fastx '{ print $name, $seq }' input.fasta

# Extract sequences based on ids in a file
# for large scale use cdbyank instead
$ bioawk -cfastx 'BEGIN{while((getline k <"IDs.txt")>0)i[k]=1}{if(i[$name])print ">"$name"\n"$seq}' input.fasta
 ```
 
### For fastq files
Here, the -c fastx option remains same but bioawk will automatically recognize the fastq format and build the required variables, such as \$name \$seq \$qual and \$comment
```bash
# Count the number of records (reads)
$ bioawk -t -c fastx 'END {print NR}' input.fastq

# Count number of reads and number of bases in a fastq file
$ sudo apt install pigz
$ pigz -dc input.fastq |
     awk 'NR%4==2{c++; l+=length($0)}
          END{
                print "Number of reads: "c; 
                print "Number of bases in reads: "l
              }'

# note that when fastq is specified, each record is 4 lines
# Convert fastq to FASTA
$ bioawk -c fastx '{print ">"$name; print $seq}' input.fastq

# Get the mean Phred quality score from fastq
# A Phred quality score is a measure of the quality of the identification of the nucleobases generated by automated DNA sequencing.
$ bioawk -c fastx '{print ">"$name; print meanqual($qual)}' input.fastq

# Filter reads shorter than 10 bp (or any bp)
$ bioawk -cfastx 'length($seq) > 10 {print "@"$name"\n"$seq"\n+\n"$qual}' input.fastq

# Trim fastq files based on quality
# trims fastq bases 0 to 5 (beginning to end), scores less than 30.
$ bioawk -c fastx ' trimq(30, 0, 5){print $0}' input.fastq

# FASTQ quality scores
head -n 10000 input.fastq |\
  awk '{if(NR%4==0) printf("%s",$0);}' |  od -A n -t u1 | \
  awk 'BEGIN{min=100;max=0;} \
      {for(i=1;i<=NF;i++) \
          {if($i>max) max=$i; \
               if($i<min) min=$i;}}END \
          {if(max<=74 && min<59) \
                     print "Phred+33"; \
           else \
           if(max>73 && min>=64) \
                     print "Phred+64"; \
           else \
           if(min>=59 && min<64 && max>73) \
                     print "Solexa+64"; else print "Unknown score encoding!";}' --- [Table of contents](/introduction/terminology_index.html)
```
Assume a genome size of ~4.6 MB. Calculate the coverage based on this formula: C = LN / G
C: Coverage
G: is the haploid genome length in bp
L: is the read length in bp (e.g. 2x150 paired-end = 300)
N: is the number of reads sequenced

## ADAPTER TRIMMING
Quality trimming of our sequencing reads will remove bad quality called bases from our reads, which is especially important when dealing with variant identification.

```bash
# create env and install tools
$ conda create --yes -n qc fastp fastqc multiqc

# Activate env
$ conda activate qc
 ```
 
Here, we are going to use the second approach with a tool called **fastp** to trim adapters and do quality trimming. **fastp** has a few characteristics which make it a great tool, most importantly: it is pretty fast, provides good information after the run, and can do quality trimming as well, thus saving us to use another tool to do this.

Here, as an example we are trimming the sequence reads of the ancestor:
```bash
$ fastp --detect_adapter_for_pe
        --overrepresentation_analysis
        --correction --cut_right --thread 2
        --html trimmed/anc.fastp.html --json trimmed/anc.fastp.json
        -i data/anc_R1.fastq.gz -I data/anc_R2.fastq.gz
        -o trimmed/anc_R1.fastq.gz -O trimmed/anc_R2.fastq.gz
```
--detect_adapter_for_pe: Specifies that we are dealing with paired-end data.

--overrepresentation_analysis: Analyse the sequence collection for sequences that appear too often.

--correction: Will try to correct bases based on an overlap analysis of read1 and read2.

--cut_right: Will use quality trimming and scan the read from start to end in a window. If the quality in the window is below what is required, the window plus all sequence towards the end is discarded and the read is kept if its still long enough.

--thread: Specify how many concurrent threads the process can use.

--html and --json: We specify the location of some stat files.

-i data/anc_R1.fastq.gz -I data/anc_R2.fastq.gz: Specifies the two input read files

-o trimmed/anc_R1.fastq.gz -O trimmed/anc_R2.fastq.gz: Specifies the two desired output read files

```bash
$ mkdir trimmed

# Run fastp like this on the ancestor:
fastp --detect_adapter_for_pe --overrepresentation_analysis --correction  --cut_right --html trimmed/anc.fastp.html --json trimmed/anc.fastp.json --thread 2 -i data/anc_R1.fastq.gz -I data/anc_R2.fastq.gz -o trimmed/anc_R1.fastq.gz -O trimmed/anc_R2.fastq.gz

# Run the evolved samples through fastp
fastp --detect_adapter_for_pe --overrepresentation_analysis --correction --cut_right --html trimmed/evol1.fastp.html --json trimmed/evol1.fastp.json --thread 2 -i data/evol1_R1.fastq.gz -I data/evol1_R2.fastq.gz -o trimmed/evol1_R1.fastq.gz -O trimmed/evol1_R2.fastq.gz

fastp --detect_adapter_for_pe --overrepresentation_analysis --correction --cut_right --html trimmed/evol2.fastp.html --json trimmed/evol2.fastp.json --thread 2 -i data/evol2_R1.fastq.gz -I data/evol2_R2.fastq.gz -o trimmed/evol2_R1.fastq.gz -O trimmed/evol2_R2.fastq.gz
 ```

## RUN FASTQC AND MULTIQC ON THE TRIMMED DATA
FastQC is a very simple program to run that provides inforation about sequence read quality.
```bash
# Installing FastQC
$ conda install -c bioconda fastqc
$ fastqc --help

# Create a directory for the results
$ mkdir fastqc_result

# Run FastQC on all trimmed files.
$ fastqc -o RESULT-DIR INPUT-FILE.fq(.gz) ...
$ fastqc -o fastqc_result input.fastq.gz
```

MultiQC is an excellent tool to put FastQC (and other tool) results of different samples into context. It compiles all FastQC results and fastp stats into one nice web-page.

The use of MultiQC is simple. Just provide the command with a directories where multiple results are stored and it will compile a nice report, e.g.:
```bash
# Run MultiQC on the trimmed data
$ multiqc DIRECTORY DIRECTORY ...
$ multiqc fastqc_result trimmed
```

```bash
# Open report html webpage:
$ google-chrome fastq_result/anc_R2_fastqc.html
```
## REFERENCES
1. Schmeier, S. (2020). *Computational Genomics Tutorial*. \[online\] Schmeierlab. Available at https://genomics.sschmeier.com. \[Accessed 24 Mar. 2023\].
2. Seetharam, A. *BioAWK basics*. \[online\] Bioinformatics Workbook. Available at https://bioinformaticsworkbook.org/Appendix/Unix/bioawk-basics.html#gsc.tab=0. \[Accessed 24 Mar. 2023\].

